{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getBgColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.5000*2., 1e-5);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getBgColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"},{"breakpoints":[],"aspectRatio":1.6,"userDownsample":0.75,"states":{"appear":[],"scroll":[],"hover":[],"mousemove":[]},"effects":["4766d765-2e95-422e-83a3-8e8355f7a76d","a783a405-93fa-4a72-8945-987b0d811197"],"anchorPoint":0,"mask":0,"maskDepthLayer":1,"layerType":"shape","width":200,"widthMode":1,"height":200,"heightMode":1,"left":0.23309027777777777,"top":0.28725555555555554,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uArtboardResolution;uniform vec2 uMousePos;const float TAU = 6.28318530718;\nconst float PI = 3.14159265;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 getAnchorOffsets() {\nreturn vec2(0.0, 0.0);\n}vec3 getFillColor(vec2 localPos, vec2 elementSize, float signedDist, float maxInset) {\nvec2 halfSize = elementSize * 0.5;\nvec2 p = localPos - halfSize;return vec3(0, 0, 0);\n}float sdBox(vec2 p, vec2 b) {\nvec2 d = abs(p) - b;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}float sdShape(vec2 canvasPosPx, vec2 elementPosPx, vec2 elementSizePx, float rotationTurns) {\nvec2 p = vec2(0.0);\nvec2 halfSize = vec2(0.0);halfSize = uArtboardResolution * 0.5;\np = canvasPosPx - halfSize;\nreturn sdBox(p, halfSize);elementSizePx = abs(elementSizePx);vec2 centerPx = elementPosPx + elementSizePx * 0.5;\nvec2 rel = canvasPosPx - centerPx;\nvec2 local = rotate2D(rel, -rotationTurns * TAU) + elementSizePx * 0.5;\np = local - elementSizePx * 0.5;\nhalfSize = elementSizePx * 0.5;\nreturn sdBox(p, halfSize);\n}vec4 sampleShape(vec2 canvasUV) {\nvec2 canvasPosPx = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);float absWidth = 200.0000;\nfloat absHeight = 200.0000;if (1 == 2) {\nabsWidth = absHeight * 1.6000;\n} else if (1 == 2) {\nabsHeight = absWidth / 1.6000;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.2331, 0.2873) * uArtboardResolution - getAnchorOffsets() * elementSizePx;float dist = sdShape(canvasPosPx, elementPosPx, elementSizePx, 0.0000);\nfloat aa = max(length(vec2(dFdx(dist), dFdy(dist))), 0.75);float fillAlpha = 1.0 - smoothstep(mix(0.0, -150., 0.0000), mix(aa, 150., 0.0000), dist);\nvec2 localPos;\nlocalPos = canvasPosPx;\nvec2 localSize;\nlocalSize = uArtboardResolution;\nvec2 centerPx;\ncenterPx = uArtboardResolution * 0.5;\nfloat centerDist = sdShape(centerPx, elementPosPx, elementSizePx, 0.0000);\nfloat maxInset = max(-centerDist, 0.00001);vec3 fillRgb = getFillColor(localPos, localSize, dist, maxInset);\nfloat finalFillAlpha = fillAlpha * 1.0000;\nvec4 fill = vec4(fillRgb * finalFillAlpha, finalFillAlpha);float strokeAlpha = 0.0;\nvec4 stroke = vec4(vec3(0, 0, 0) * strokeAlpha, strokeAlpha);\nvec4 col = stroke + fill * (1.0 - stroke.a);\nreturn col;\n}vec4 getSourceOutput(vec2 uv) {\nreturn sampleShape(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = (uMousePos - 0.5) * 0.0000;uv -= pos;fragColor = getSourceOutput(uv);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.6}},"compositeShader":{"fragmentShader":"#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uBgTexture;\nuniform sampler2D uTexture;const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0);uv -= pos;vec4 background = vec4(0);background = texture(uBgTexture, vTextureCoord);\nvec4 color = texture(uTexture, uv);vec4 col = getOutputByMode(color, background);fragColor = col;\n}","vertexShader":"#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"},"compositeUniforms":{"resolution":{"name":"uResolution","type":"2f","value":{"type":"Vec2","_x":1080,"_y":1080}},"opacity":{"name":"uOpacity","type":"1f","value":1},"mousePos":{"name":"uMousePos","type":"2f","value":{"type":"Vec2","_x":0.5,"_y":0.5}}}},"id":"shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.75,"layerType":"effect","type":"waterRipple","usesPingPong":true,"speed":0.46,"mouseMomentum":0,"texture":false,"parentLayer":"4766d765-2e95-422e-83a3-8e8355f7a76d","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uPingPongTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;out vec4 fragColor;vec3 calculateNormal(sampler2D tex, vec2 uv) {\nfloat stengthScale = mix(3., 7., 0.4600);\nfloat stepScale = mix(1., 3., 0.4600);\nfloat strength = mix(1., stengthScale, 1.0000);\nfloat stepSize = mix(1., stepScale, 1.0000);\nfloat step = stepSize / 1080.;\nfloat left = texture(tex, uv + vec2(-step, 0.0)).r;\nfloat right = texture(tex, uv + vec2(step, 0.0)).r;\nfloat top = texture(tex, uv + vec2(0.0, -step)).r;\nfloat bottom = texture(tex, uv + vec2(0.0, step)).r;\nvec3 normal;\nnormal.x = (right - left) * strength;\nnormal.y = -(bottom - top) * strength;\nnormal.z = -1.0;\nreturn normalize(normal);\n}vec4 drawRipple(vec2 uv) {\nvec2 scaled = mix(uv, (uv - 0.5) * 0.5 + 0.5, 0.4600);\nvec3 normal = calculateNormal(uPingPongTexture, scaled);\nreturn vec4(normal, 1.);\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec4 getColor(vec2 uv) {\nreturn drawRipple(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;float getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.7978845608028654;\ncase 1: return 0.795118932516684;\ncase 2: return 0.7868794322038799;\ncase 3: return 0.7733362336056986;\ncase 4: return 0.7547664553859864;\ncase 5: return 0.7315447328280048;\ncase 6: return 0.704130653528599;\ncase 7: return 0.6730536454899063;\ncase 8: return 0.6388960110447045;\ncase 9: return 0.6022748643096089;\ncase 10: return 0.5638237508206051;\ncase 11: return 0.5241747061566029;\ncase 12: return 0.48394144903828673;\ncase 13: return 0.443704309411472;\ncase 14: return 0.40399737110811773;\ncase 15: return 0.36529817077804383;\ncase 16: return 0.3280201493519873;\ncase 17: return 0.29250790855907144;\ncase 18: return 0.2590351913317835;\ncase 19: return 0.2278053882403838;\ncase 20: return 0.19895427758549736;\ncase 21: return 0.17255463765302306;\ncase 22: return 0.1486223271179862;\ncase 23: return 0.12712341303392466;\ndefault: return 0.0;\n}\n}out vec4 fragColor;vec4 blur(vec2 uv, vec2 dir) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getGaussianWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;\nfor (int i = 1; i <= 11; i++) {\nfloat weight = getGaussianWeight(i);\nfloat offset = mix(0.005, 0.015, 0.4800) * float(i)/11.;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, 0));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;float getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.7978845608028654;\ncase 1: return 0.795118932516684;\ncase 2: return 0.7868794322038799;\ncase 3: return 0.7733362336056986;\ncase 4: return 0.7547664553859864;\ncase 5: return 0.7315447328280048;\ncase 6: return 0.704130653528599;\ncase 7: return 0.6730536454899063;\ncase 8: return 0.6388960110447045;\ncase 9: return 0.6022748643096089;\ncase 10: return 0.5638237508206051;\ncase 11: return 0.5241747061566029;\ncase 12: return 0.48394144903828673;\ncase 13: return 0.443704309411472;\ncase 14: return 0.40399737110811773;\ncase 15: return 0.36529817077804383;\ncase 16: return 0.3280201493519873;\ncase 17: return 0.29250790855907144;\ncase 18: return 0.2590351913317835;\ncase 19: return 0.2278053882403838;\ncase 20: return 0.19895427758549736;\ncase 21: return 0.17255463765302306;\ncase 22: return 0.1486223271179862;\ncase 23: return 0.12712341303392466;\ndefault: return 0.0;\n}\n}out vec4 fragColor;vec4 blur(vec2 uv, vec2 dir) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getGaussianWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;\nfor (int i = 1; i <= 11; i++) {\nfloat weight = getGaussianWeight(i);\nfloat offset = mix(0.005, 0.015, 0.4800) * float(i)/11.;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(0, 1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;out vec4 fragColor;vec3 chromatic_aberration(vec3 color, vec2 uv) {\nvec2 offset = (uv - vTextureCoord) * (0.0000 * 0.2);\nvec4 left = texture(uBgTexture, uv - offset);\nvec4 right = texture(uBgTexture, uv + offset);color.r = left.r;\ncolor.b = right.b;return color;\n}vec2 calculateRefraction(vec3 normal, float ior) {\nvec3 I = vec3(0.0, 0.0, 1.0);\nfloat ratio = 1.0 / ior;\nvec3 refracted = refract(I, normal, ratio);\nfloat refractionScale = mix(0.2, 0.4, 0.4600);\nfloat refractionAmount = mix(0.01, refractionScale, 1.0000);\nreturn refracted.xy * refractionAmount;\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec3 calculateLighting(vec3 normal, vec2 uv) {\nvec3 N = normal;\nvec3 worldPos = vec3(uv * 2.0 - 1.0, 0.0);\nvec3 lightDir = normalize(LIGHT_POS - worldPos);\nvec3 viewDir = normalize(VIEW_POS - worldPos);\nvec3 reflectDir = reflect(-lightDir, N);\nfloat diff = max(dot(N, lightDir), 0.0);\nvec3 diffuse = vec3(diff);\nfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS);\nvec3 specular = vec3(spec * SPECULAR);\nreturn diffuse + specular;\n}vec4 getRipple(vec2 uv) {\nvec3 normal = texture(uTexture, uv).rgb;\nvec2 refractionOffset = calculateRefraction(normal, 1.333);\nvec2 refractedUv = uv + refractionOffset;\nvec3 refractedNormal = texture(uTexture, refractedUv).rgb;vec4 refractedColor = texture(uBgTexture, refractedUv);\nrefractedColor.rgb = chromatic_aberration(refractedColor.rgb, refractedUv);vec3 caustics = calculateLighting(refractedNormal, refractedUv);\nfloat causticsShadow = dot(normal, normalize(vec3(2.0, -2.0, 3.0) - vec3(uv * 2.0 - 1.0, 0.0))) + 1.;\nfloat shadowFactor = causticsShadow;\nvec3 lightingFactor = caustics;shadowFactor = mix(1., shadowFactor, 1.0000);\nlightingFactor = mix(vec3(0), lightingFactor * vec3(1, 1, 1), 1.0000);\nvec4 finalColor = vec4(refractedColor.rgb - vec3(1.-shadowFactor) * vec3(1, 1, 1) + lightingFactor, refractedColor.a);\nreturn finalColor;\n}vec4 getColor(vec2 uv) {\nreturn getRipple(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uPingPongTexture;\nuniform vec2 uPreviousMousePos;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float TWOPI = 6.2831852;out vec4 fragColor;void main() {\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1);\nvec2 texelSize = (1.0 / (vec2(1080) * aspect)) * mix(1., 8., 0.4600);\nvec2 vUv = vTextureCoord;\nvec2 mPos = mix(uMousePos, (uMousePos - 0.5) * 0.5 + 0.5, 0.4600);\nvec2 pmPos = mix(uPreviousMousePos, (uPreviousMousePos - 0.5) * 0.5 + 0.5, 0.4600);float waveSpeed = 1.;\nfloat damping = mix(0.8, 0.999, 0.9100);\nfloat velocityDamping = damping;\nfloat heightDamping = damping;\nfloat time = 0.5;vec4 data = texture(uPingPongTexture, vUv);\nfloat height = data.r;\nfloat velocity = data.g;float laplacian = 0.0;\nfloat totalWeight = 0.0;\nfloat scaleDiff = 0.4600 * 0.25;\nvec2 clampRegionMin = vec2(0.4600 * 0.5 - scaleDiff);\nvec2 clampRegionMax = vec2(1.0 - 0.4600 * 0.5 + scaleDiff);\nvec2 offset = vec2(texelSize.x, 0.0);\nvec2 neighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nfloat weight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;\noffset = vec2(-texelSize.x, 0.0);\nneighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nweight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;\noffset = vec2(0.0, texelSize.y);\nneighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nweight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;\noffset = vec2(0.0, -texelSize.y);\nneighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nweight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;float avgNeighbors = laplacian / totalWeight;\nlaplacian = avgNeighbors - height;velocity += waveSpeed * waveSpeed * laplacian;\nvelocity *= velocityDamping;\nheight += velocity;\nheight *= heightDamping;float mouseSpeed = distance(mPos * aspect, pmPos * aspect);\nfloat dist = distance(vUv * aspect, mPos * aspect);\nfloat radius = 0.025;\nif (dist < radius && mouseSpeed > 0.0001) {\nfloat drop = cos(dist / radius * PI * time);\nfloat intensity = mouseSpeed * 20.;\nheight += drop * intensity;\n}fragColor = vec4(height, velocity, 0.0, 1.0);\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25},{"prop":"pass","value":3,"includeBg":true}]},"id":"water_ripple"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.75,"layerType":"effect","type":"twod_sdf","usesPingPong":false,"texture":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":1,"parentLayer":"a783a405-93fa-4a72-8945-987b0d811197","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float sdEquilateralTriangle(vec2 p, float r ) {\nconst float k = sqrt(3.0);\np.x = abs(p.x) - r;\np.y = p.y + r/k;\nif( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\np.x -= clamp( p.x, -2.0*r, 0.0 );\nreturn -length(p)*sign(p.y);\n}float getDistance(vec2 uv) {\nreturn sdEquilateralTriangle(uv, 0.4);\n}float getDist(vec2 uv) {\nfloat sd = getDistance(uv);vec2 aspect = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 mousePos = (uMousePos * aspect);\nfloat mouseDistance = length(vTextureCoord * aspect - mousePos);\nfloat falloff = smoothstep(0.0, 0.8, mouseDistance);\nfloat asd = 2.0;asd = -asd;float md = mix(0.02/falloff, 0.1/falloff, -asd * sd);\nmd = md * 1.5 * 0.0000;\nmd = min(-md, 0.0);\nsd -= md;return sd;\n}vec4 refrakt(float sd, vec2 st, vec4 bg) {sd = -sd;vec2 offset = mix(vec2(0), normalize(st)/sd, length(st));vec4 r = vec4(0,0,0,1);\nfloat rdisp = mix(0.01, 0.008, 0.5000);\nfloat gdisp = mix(0.01, 0.01, 0.5000);\nfloat bdisp = mix(0.01, 0.012, 0.5000);\nvec2 uv = (vTextureCoord - 0.5) / mix(1., 4., 0.0000) + 0.5;\nr.r = texture(uTexture, uv + offset * (1.2500 - 0.5) * rdisp).r;\nr.g = texture(uTexture, uv + offset * (1.2500 - 0.5) * gdisp).g;\nr.b = texture(uTexture, uv + offset * (1.2500 - 0.5) * bdisp).b;\nfloat opacity = ceil(-sd);\nfloat smoothness = 0.0025;\nopacity = smoothstep(0., smoothness, -sd);vec4 background = vec4(0);\nreturn mix(background, r + vec4(vec3(0.4, 0.1, 1)/(-sd * 50.), 1.) * 0.0000, opacity);\n}vec4 getEffect(vec2 st, vec4 bg) {\nfloat eps = 0.0005;float sd = getDist(st);\nfloat sd1 = getDist(st + vec2(eps, 0.0));\nfloat sd2 = getDist(st - vec2(eps, 0.0));\nfloat sd3 = getDist(st + vec2(0.0, eps));\nfloat sd4 = getDist(st - vec2(0.0, eps));vec4 r = refrakt(sd, st, bg);\nvec4 r1 = refrakt(sd1, st + vec2(eps, 0.0), bg);\nvec4 r2 = refrakt(sd2, st - vec2(eps, 0.0), bg);\nvec4 r3 = refrakt(sd3, st + vec2(0.0, eps), bg);\nvec4 r4 = refrakt(sd4, st - vec2(0.0, eps), bg);\nr = (r + r1 + r2 + r3 + r4) * 0.2;\nreturn r;\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nvec4 color = vec4(1);\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000);\nvec2 st = uv - (vec2(0.5, 0.4484320557491289) + mousePos);\nst *= aspect;\nst *= 1./(0.5280 + 0.2);\nst *= rot(0.0000 * 2.0 * PI);\ncolor = getEffect(st, bg);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"2d_sdf_shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"coloration","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;vec3 Tonemap_Uncharted2(vec3 x) {\nx *= 16.;\nconst float A = 0.15;\nconst float B = 0.50;\nconst float C = 0.10;\nconst float D = 0.20;\nconst float E = 0.02;\nconst float F = 0.30;\nreturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}vec3 getFilteredColor(vec3 color) {\nreturn Tonemap_Uncharted2(color);\n}float hueToRgb(float p, float q, float t) {\nif (t < 0.0) t += 1.0;\nif (t > 1.0) t -= 1.0;\nif (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t;\nif (t < 1.0 / 2.0) return q;\nif (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0;\nreturn p;\n}vec3 hslToRgb(vec3 hsl) {\nfloat h = hsl.x;\nfloat s = hsl.y;\nfloat l = hsl.z;\nvec3 rgb = vec3(l);\nif (s != 0.0) {\nfloat q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\nfloat p = 2.0 * l - q;\nrgb.r = hueToRgb(p, q, h + 1.0 / 3.0);\nrgb.g = hueToRgb(p, q, h);\nrgb.b = hueToRgb(p, q, h - 1.0 / 3.0);\n}\nreturn rgb;\n}vec3 rgbToHsl(vec3 rgb) {\nfloat max = max(max(rgb.r, rgb.g), rgb.b);\nfloat min = min(min(rgb.r, rgb.g), rgb.b);\nfloat h, s, l = (max + min) / 2.0;if (max == min) {\nh = s = 0.0;\n} else {\nfloat d = max - min;\ns = l > 0.5 ? d / (2.0 - max - min) : d / (max + min);\nif (max == rgb.r) {\nh = (rgb.g - rgb.b) / d + (rgb.g < rgb.b ? 6.0 : 0.0);\n} else if (max == rgb.g) {\nh = (rgb.b - rgb.r) / d + 2.0;\n} else if (max == rgb.b) {\nh = (rgb.r - rgb.g) / d + 4.0;\n}\nh /= 6.0;\n}return vec3(h, s, l);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);if(color.a <= 0.001) {\nfragColor = vec4(0);\nreturn;\n}color.rgb = rgbToHsl(color.rgb);\ncolor.x = fract(color.x + 1.0000);\ncolor.y = clamp(color.y * 1.0000, 0.0, 1.0);\ncolor.z = clamp(color.z + 0.0000, 0.0, 1.0);\ncolor.rgb = hslToRgb(color.rgb);\ncolor.rgb = getFilteredColor(color.rgb);color.rgb = 1.4900 * (color.rgb - 0.5) + 0.5;color.r = clamp(color.r + 0.0000, 0.0, 1.0);\ncolor.b = clamp(color.b - 0.0000, 0.0, 1.0);color.g = clamp(color.g - 0.0000, 0.0, 1.0);\ncolor.r = clamp(color.r + 0.0000 * 0.5, 0.0, 1.0);\ncolor.b = clamp(color.b + 0.0000 * 0.5, 0.0, 1.0);color.rgb = pow(max(color.rgb, 0.0001), vec3(1.0 / (max(1.0000, 0.0) + 1.0)));color = vec4(clamp(color.rgb, 0.0, 1.0), color.a);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"adjust"}],"options":{"name":"Vercel Ship Inspired (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.5","id":"ihElhZfGwKlJ188deQnl"}
