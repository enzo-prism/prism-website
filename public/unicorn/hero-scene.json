{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform float uTime;\nuniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(1, 1, 1);\ncase 3: return vec3(1, 1, 1);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 0.3333;\ncase 2: return 0.6667;\ncase 3: return 1.0000;\ncase 4: return 0.0000;\ncase 5: return 0.0000;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(max(rgb, vec3(0.0)), vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(max(lin, vec3(0.0)), vec3(1.0/2.2));\n}vec3 safeCbrt(vec3 v) {\nreturn sign(v) * pow(abs(v), vec3(1.0/3.0));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = safeCbrt( kCONEtoLMS*lin1 );\nvec3 lms2 = safeCbrt( kCONEtoLMS*lin2 );\nvec3 lms = mix( lms1, lms2, a );\nlms *= 1.0 + 0.025 * a * (1.0-a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nif (4 <= 1) return getColor(0);for (int i = 0; i < 15; i++) {\nif (i >= 4 - 1) break;\nfloat stopA = getStop(i);\nfloat stopB = getStop(i + 1);\nif (position <= stopB || i == 4 - 2) {\nfloat denom = max(stopB - stopA, 0.00001);\nfloat t = clamp((position - stopA) / denom, 0.0, 1.0);\nvec3 linA = linear_from_srgb(getColor(i));\nvec3 linB = linear_from_srgb(getColor(i + 1));\nvec3 mixed = oklab_mix(linA, linB, t);\nreturn srgb_from_linear(mixed);\n}\n}\nreturn getColor(min(4 - 1, 15));\n}out vec4 fragColor;vec3 applyColorToPosition(float position) {\nvec3 color = vec3(0);\nposition -= (uTime * 0.01 + 0.0000);\nfloat cycle = floor(position);\nbool reverse = 1.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor += dither;\nreturn color;\n}vec3 linearGrad(vec2 uv) {\nfloat position = (uv.x+0.5);\nreturn applyColorToPosition(position);\n}vec3 getGradient(vec2 uv) {\nreturn linearGrad(uv);\n}vec3 getBgColor(vec2 uv) {return getGradient(uv);return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.5000*2., 1e-5);\nuv = rotate(uv, (0.5000 - 0.5) * 2. * PI);\nvec4 color = vec4(getBgColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"noiseBlur","usesPingPong":false,"speed":0.5,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uResolution;vec4 permute(vec4 t) {\nreturn t * (t * 34.0 + 133.0);\n}vec3 grad(float hash) {\nvec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\nvec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0));\nfloat index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0;\ncuboct.y *= 1.0 - index1;\ncuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0);\nvec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad;\n}\nvec4 bccNoiseDerivativesPart(vec3 X) {\nvec3 b = floor(X);\nvec4 i4 = vec4(X - b, 2.5);\nvec3 v1 = b + floor(dot(i4, vec4(.25)));\nvec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\nvec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\nvec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\nvec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\nhashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\nhashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\nvec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\nvec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\nvec4 aa = a * a; vec4 aaaa = aa * aa;\nvec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\nvec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\nvec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\nvec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n+ mat4x3(g1, g2, g3, g4) * aaaa;\nreturn vec4(derivative, dot(aaaa, extrapolations));\n}\nvec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) {\nmat3 orthonormalMap = mat3(\n0.788675134594813, -0.211324865405187, -0.577350269189626,\n-0.211324865405187, 0.788675134594813, -0.577350269189626,\n0.577350269189626, 0.577350269189626, 0.577350269189626);\nX = orthonormalMap * X;\nvec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\nreturn vec4(result.xyz * orthonormalMap, result.w);\n}const int MAX_ITERATIONS = 32;\nconst float MAX_ITERATIONS_F = 32.0;\nconst float HALF_ITERATIONS = 16.0;out vec4 fragColor;const float PI = 3.14159265;mat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}void main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 noiseUv = rot(0.0139 * -1. * 2.0 * PI) *\n(uv * vec2(aspectRatio, 1.) - vec2(-0.04, 0.5) * vec2(aspectRatio, 1.)) *\nvec2(0.0200, 1.-0.0200) * 5. * 1.4200;\nvec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(noiseUv, uTime * 0.025 + 0.0000 * 2.));\nvec2 noiseOffset = (noise.xy - 0.5) * (3.4600 + 0.01) * 0.25;\nvec4 color = vec4(0.0);\nfor (int i = 0; i < MAX_ITERATIONS; i++) {\nfloat offset = float(i) - HALF_ITERATIONS;\nvec2 st = uv + noiseOffset * (offset / MAX_ITERATIONS_F);\ncolor += texture(uTexture, st);\n}\ncolor /= MAX_ITERATIONS_F;\nfragColor = color;}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uResolution;vec4 permute(vec4 t) {\nreturn t * (t * 34.0 + 133.0);\n}vec3 grad(float hash) {\nvec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\nvec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0));\nfloat index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0;\ncuboct.y *= 1.0 - index1;\ncuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0);\nvec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad;\n}\nvec4 bccNoiseDerivativesPart(vec3 X) {\nvec3 b = floor(X);\nvec4 i4 = vec4(X - b, 2.5);\nvec3 v1 = b + floor(dot(i4, vec4(.25)));\nvec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\nvec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\nvec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\nvec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\nhashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\nhashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\nvec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\nvec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\nvec4 aa = a * a; vec4 aaaa = aa * aa;\nvec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\nvec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\nvec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\nvec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n+ mat4x3(g1, g2, g3, g4) * aaaa;\nreturn vec4(derivative, dot(aaaa, extrapolations));\n}\nvec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) {\nmat3 orthonormalMap = mat3(\n0.788675134594813, -0.211324865405187, -0.577350269189626,\n-0.211324865405187, 0.788675134594813, -0.577350269189626,\n0.577350269189626, 0.577350269189626, 0.577350269189626);\nX = orthonormalMap * X;\nvec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\nreturn vec4(result.xyz * orthonormalMap, result.w);\n}const int MAX_ITERATIONS = 32;\nconst float MAX_ITERATIONS_F = 32.0;\nconst float HALF_ITERATIONS = 16.0;out vec4 fragColor;const float PI = 3.14159265;mat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}void main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 noiseUv = rot(0.0139 * -1. * 2.0 * PI) *\n(uv * vec2(aspectRatio, 1.) - vec2(-0.04, 0.5) * vec2(aspectRatio, 1.)) *\nvec2(0.0200, 1.-0.0200) * 5. * 1.4200;\nvec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(noiseUv, uTime * 0.025 + 0.0000 * 2.));\nvec2 noiseOffset = (noise.xy - 0.5) * (3.4600 + 0.01) * 0.25;\nvec4 color = vec4(0.0);\nfor (int i = 0; i < MAX_ITERATIONS; i++) {\nfloat offset = float(i) - HALF_ITERATIONS;\nvec2 st = uv + noiseOffset * (offset / MAX_ITERATIONS_F);\ncolor += texture(uTexture, st);\n}\ncolor /= MAX_ITERATIONS_F;\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5}]},"id":"noise_blur"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"9782d4c4-4930-4888-8ed2-9653633881ac","prop":"angle","transition":{"delay":0,"duration":90000,"ease":"linear"},"complete":false,"progress":0,"value":0,"endValue":-3,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uAngle"}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"df1c7930-7207-41eb-bafe-5a34e23accec","prop":"pinch","transition":{"duration":90000,"ease":"easeInOutQuart","delay":0},"complete":false,"progress":0,"value":0,"endValue":-3,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uPinch"}}],"scroll":[],"hover":[],"mousemove":[]},"layerType":"effect","type":"swirl","usesPingPong":false,"angle":0,"pinch":0,"speed":0.5,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform float uAngle;\nuniform float uTime;\nuniform float uPinch;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;\nvoid main() {\nvec2 uv = vTextureCoord;\nfloat angle = uAngle * 10.;\nvec2 originalUV = uv;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);uv -= pos;\nvec2 R = vec2(uv.x * uResolution.x / uResolution.y, uv.y);\nfloat distanceToCenter = length(R);\ndistanceToCenter += uPinch*0.5;\nif (distanceToCenter <= 1.6200) {\nfloat rot = atan(R.y, R.x) + angle * smoothstep(1.6200, 0., distanceToCenter);\nuv = vec2(cos(rot + uTime / 20. + 0.0000 * 6.28), sin(rot + uTime / 20. + 0.0000 * 6.28));\nuv = distanceToCenter * uv + pos;\n}\nfloat t = smoothstep(0., 1.6200, distanceToCenter);\nvec2 mixedUV = mix(uv, originalUV, t);vec4 color = texture(uTexture, mix(vTextureCoord, mixedUV, 1.0000));\nfragColor = color;}","#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uPingPongTexture;\nuniform vec2 uPreviousMousePos;\nuniform float uRadius;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) {\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}mat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}vec2 liquify(vec2 st, vec2 dir) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nst.x *= aspectRatio;\nfloat amplitude = 0.0025;\nfloat freq = 6.;\nfor (float i = 1.0; i <= 5.0; i++) {\nst = st * rot(i / 5.0 * PI * 2.0);\nst += vec2(\namplitude * cos(i * freq * st.y + uTime * 0.02 * dir.x),\namplitude * sin(i * freq * st.x + uTime * 0.02 * dir.y)\n);\n}\nst.x /= aspectRatio;\nreturn st;\n}vec3 calculateTrailContribution(vec2 mousePos, vec2 prevMousePos, vec2 uv, vec2 correctedUv, float aspectRatio, float radius) {\nvec2 dir = (mousePos - prevMousePos) * vec2(aspectRatio, 1.0);\nfloat angle = atan(dir.y, dir.x);\nif (angle < 0.0) angle += TWOPI;\nvec2 mouseVec = mousePos - prevMousePos;\nfloat mouseLen = length(mouseVec);\nvec2 mouseDir = mouseLen > 0.0 ? mouseVec / mouseLen : vec2(0.0);\nvec2 posToUv = (correctedUv - prevMousePos) * vec2(aspectRatio, 1.0);\nfloat projection = clamp(dot(posToUv, mouseDir * vec2(aspectRatio, 1.0)), 0.0, mouseLen * aspectRatio);\nvec2 closestPoint = prevMousePos * vec2(aspectRatio, 1.0) + mouseDir * vec2(aspectRatio, 1.0) * projection;\nfloat distanceToLine = distance(correctedUv, closestPoint);\nfloat s = (1.0 + radius)/(distanceToLine + radius) * radius;\nvec3 color = vec3(angle / TWOPI, 1.0, 1.0);\nvec3 pointColor = hsv2rgb(color);\npointColor = pow(pointColor, vec3(2.2));\nfloat intensity = pow(s, 10.0 * (1. - 0.0000 + 0.1));\nreturn pointColor * intensity;\n}void main() {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 uv = vTextureCoord;\nvec2 correctedUv = (uv) * vec2(aspectRatio, 1.0);vec3 lastFrameColor = texture(uPingPongTexture, uv).rgb;\nvec3 lastFrameColorGamma = pow(lastFrameColor, vec3(2.2));\nvec3 hsv = rgb2hsv(lastFrameColor);\nvec3 hsvGamma = rgb2hsv(lastFrameColorGamma);\nvec2 prevDir = angleToDir(hsv.x);\nfloat prevStrength = hsvGamma.z;\nvec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0);\nfloat dist = length(dir);\nfloat blurAmount = 0.03 * prevStrength;\nuv = uv - prevDir * blurAmount;\nuv = mix(uv, liquify(uv - prevDir * 0.005, prevDir), (1. - prevStrength) * 0.8800);\nlastFrameColor = texture(uPingPongTexture, uv).rgb;\nlastFrameColor = pow(lastFrameColor, vec3(2.2));\nint numPoints = int(max(12.0, dist * 24.0));\nfloat speedFactor = clamp(dist, 0.7, 1.3);\nfloat radius = mix(0.1, 0.7, uRadius * speedFactor);\nvec3 trailColor = vec3(0.0);\nint iter = min(numPoints, 24);\nfor (int i = 0; i <= iter; i++) {\nfloat t = float(i) / float(numPoints);\nvec2 interpPos = mix(uPreviousMousePos, uMousePos, t);\nvec2 prevInterpPos = i > 0 ? mix(uPreviousMousePos, uMousePos, float(i-1) / float(numPoints)) : uPreviousMousePos;\ntrailColor += calculateTrailContribution(interpPos, prevInterpPos, uv, correctedUv, aspectRatio, radius);\n}\ntrailColor = trailColor / float(min(numPoints, 50) + 1);\nvec3 blurredLastFrame = vec3(0.0);\nfloat clampedDist = clamp(length(trailColor) * dist, 0.0, 1.0);\nfloat blurRadius = 0.005;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(-blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, blurRadius)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, -blurRadius)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += lastFrameColor * 0.2;\nblurredLastFrame *= pow(0.9900, 0.2);\nvec3 draw = mix(blurredLastFrame, trailColor, clampedDist);\ndraw = pow(draw, vec3(1.0/2.2));\ndraw.r = max(0.0, draw.r - 0.01);\ndraw.g = max(0.0, draw.g - 0.01);\ndraw.b = max(0.0, draw.b - 0.01);\nfragColor = vec4(draw, 1.0);\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"light_trail"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"glyphDither","usesPingPong":false,"texture":{"src":"data:image/png;base64,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LrtMXnjhhZJhUmFRgWD37bffjhZtv/3tbyPh7l577RUt5Cgfk07aCzkm4TfffLNUNrecrvuWW24pIcQk9OKLL8o333wjM2bMiKW95557SnRpOJgUWfDOnDkzEvixmYRQF4MbISBx0IBxGmWwebL4cTE6+uij5Z133ok23Xr16hW15+677y6TJk0SfnRJR5uyUN95552j+N12202uvvpqeeihh4hOxYTa/8DCxQ837davX78YDrPNNlusj0FXzvTt2zeWLu+erPQ/2w49evSQJ598Uj788EM555xzhPm45ywBPswq44SNfhjVqVOnyiabbGKTBWn/+te/lvfeey/WL5955hmhTdIuMEw8qpmee+45Of3006V3797CnIzwD2bmu+++E24nw1ikXRY3/9Ddofa/gw46KNaPjjzySGHR/vrrr0cbwAcffLBsvvnmAsN64IEHRvzBxx9/LAMHDgwd8rqWL7T2ZS5wf6dC5Q9sI4WGny3X8ccfHxsfLqa1us8991ybXSr2f/7zn5rL2L1791TKUCnTLM0vjBn4QtYkV1xxhQwYMCD6bdtoo42ijX14hDvvvDOqKnw+N1Vcc8kll0Rxef+DAIO1o+3/rH38OsOj2Hhr8xvi0+23336xvpv2mjML/AtrxxDW535b6fjwEcmnP2T+L6Txq/KrfPb/SrU64ogj5P33348OxZ522mmCrAgZAgdjkaEiUxg5cqR8++230aFA5IWV8korPKTxUa6OHLhHBoOM+eabb454rPXWW0+QWfKe1OWXXy5ffvlldJiyXPpKYa0Nh8+zfIm1Q5X/hczfu7jT38EQ3hhZOHwhsnEMbsKIgwYex02blrsR64/CbXCttdZa4p7iuOGGG9Jqz2b5+gsGBI9shCDYbUbsBDDpsIhh99gJTtTZsWPHVuV36623RrcFWKTPMcccrUrbXmLw4scNYa4xpmJ2xphoUfzBBx9Em0gVCROO2HfffaVSW7EwR8BFm5b77AYbbCD8eEsK/0Ltf4yDFKpb2CxD7X80CIwTm1uoEDKm8tiFFsHMAw88IH//+9/xBmdYVL3yyiuRiiRbOBhqxvZrr71mgxK3EW4g+IOJR8BV6QPGGFl77bWjDbitttqqElmhwrPU/7htwublUkstVbGN2PS/8MIL5d57761IU6SILLSvzs9t65Eu3962HNJPZUz13zQRSb8Q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","sampler":"uCustomTexture"},"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uSprite;\nuniform sampler2D uCustomTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.7600);float baseGrid = 1.0 / gridSize;\nvec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection;\nvec2 offsetUv = uv - pos;\nvec2 cell = floor(offsetUv / cellSize);\nvec2 cellCenter = (cell + 0.5) * cellSize;\nvec2 pixelatedCoord = cellCenter + pos;\nvec4 bg = texture(uTexture, vTextureCoord);\nvec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\nluminance = mix(luminance, 1.0 - luminance, float(0));\nfloat gamma = pow(mix(0.2, 2.2, 0.4000), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0);\nivec2 spriteTextureSize = textureSize(uSprite, 0);\nfloat selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(6 == 6));\nfloat GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(6 == 6));\nfloat scaleFactor = gridSize / GLYPH_HEIGHT;\nfloat numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT);\nfloat numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0);\nfloat spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0);\nfloat phaseOffset = floor(0.0000 * numSprites + 0.5);\nspriteIndexWithGamma = mod(spriteIndexWithGamma + phaseOffset, numSprites);\nfloat glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites;\nfloat normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2(spriteX, glyphIndex / numGlyphRows);vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection;\nvec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT;\nlocalOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2(localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY);vec4 spriteColor = vec4(0.0);spriteColor = texture(uCustomTexture, spriteSheetUV);\nfloat alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4;\nvec3 col = cc;\ncol = vec3(1, 1, 1);vec3 dithered = mix(\nmix(vec3(0.0), vec3(1.0), float(0)),\ncol,\nalpha\n);\ncolor.rgb = mix(bg.rgb, dithered, 1.0000);\nfragColor = color;}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uSprite"}},"id":"glyph_dither"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"retro_screen","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uResolution;out vec4 fragColor;vec3 gammaCorrect(vec3 color, float gamma) {\nreturn pow(color, vec3(1.0 / gamma));\n}float interleavedGradientNoise(vec2 st) {\nreturn fract(52.9829189 * fract(dot(st, vec2(0.06711056, 0.00583715))));\n}vec3 styleThree(vec2 curvedUV) {\nfloat cellPadding = 0.0;\nfloat pixelHeight = 1.5;float aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float size = max(3.0 / 1080.0, 0.015 * (1.0 - 1.0000));\nvec2 cellSize = vec2(size * 0.75 / aspectRatio, size * 1.75) * aspectCorrection;\ncellSize = floor(cellSize * vec2(1080)) / vec2(1080);vec2 staggeredUV = curvedUV;\nif (mod(floor(curvedUV.x / cellSize.x), 2.0) > 0.5) {\nstaggeredUV.y += 0.5 * cellSize.y;\n}vec2 cellCoords = floor(staggeredUV / cellSize) * cellSize;vec2 unstaggerOffset = vec2(0.0);\nif (mod(floor(curvedUV.x / cellSize.x), 2.0) > 0.5) {\nunstaggerOffset.y = -0.5 * cellSize.y;\n}vec2 sampleCoord = cellCoords + 0.5 * cellSize + unstaggerOffset;\nvec2 cellPos = mod(staggeredUV, cellSize) / cellSize;vec3 finalColor = vec3(0.0);\nvec3 blurColor = vec3(0.0);\nfloat blurFactor = 1.0 / 9.0;\nfor (int dx = -1; dx <= 1; dx++) {\nfor (int dy = -1; dy <= 1; dy++) {\nvec2 offset = vec2(float(dx), dy) * cellSize * 0.0000;\nblurColor += texture(uTexture, sampleCoord + offset).rgb;\n}\n}blurColor *= blurFactor;float distFromCenter = length(cellPos - 0.5);\nfloat noise = interleavedGradientNoise(curvedUV * uResolution);\nfloat pixelFactor = smoothstep(pixelHeight * 0.666, 0.0, distFromCenter + noise * 0.05);vec3 gradientColor = vec3(0.0);\ngradientColor.r = smoothstep(0.0, 0.5, cellPos.y) * smoothstep(1.0, 0.5, cellPos.y);\ngradientColor.g = smoothstep(0.25, 0.75, cellPos.y) * smoothstep(1.5, 0.5, cellPos.y);\ngradientColor.b = smoothstep(0.5, 1.0, cellPos.y) * smoothstep(1.5, 1.0, cellPos.y);gradientColor *= vec3(0.9, 1.1, 2.2);finalColor = mix(blurColor, gradientColor * blurColor, 0.4) * pixelFactor * 1.5;\nfinalColor = floor(finalColor * 16.0000) / 16.0000;\nfinalColor = gammaCorrect(finalColor, 3.0 * 0.5000);float flicker = 1.0 + 0.03 * cos(sampleCoord.x / 60.0 + uTime * 20.0);\nfinalColor *= mix(1.0, flicker, 1.4800);return finalColor;\n}void main() {\nvec3 finalColor;vec4 color = texture(uTexture, vTextureCoord);if(color.a <= 0.001) {\nfragColor = vec4(0);\nreturn;\n}finalColor = styleThree(vTextureCoord);vec4 bg = texture(uTexture, vTextureCoord);vec4 col = mix(bg, vec4(finalColor, bg.a), 0.6000);\nfragColor = col;}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;out vec2 vTextureCoord;\nout vec3 vVertexPosition;\nout float zPos;uniform sampler2D uCustomTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;float ease (int easingFunc, float t) {\nreturn t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n}float bezier(float t) {\nreturn ease(3, t);\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 bulge(vec3 pos) {\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1);\nvec2 mousePosAdjusted = mix((vec2(0.5, 0.5) - 0.5) * 2., (uMousePos - 0.5) * 2., 0.0000);\nvec2 skew = vec2(0.3700, 1. - 0.3700);\nmat2 rotation = rot(0.5000 * 2. * 3.14159);float dist = distance(pos.xy * aspectRatio * rotation * skew, mousePosAdjusted * aspectRatio * rotation * skew);float t = max(0., 1. - dist/0.9100);\nfloat bulge = bezier(t) * (0.6000 - 0.5);float luma = dot(texture(uCustomTexture, (pos.xy + 1.) * 0.5).rgb, vec3(0.299, 0.587, 0.114));bulge += luma * bezier(t) * 0.0050;\nbulge = min(1., bulge);pos.xy += bulge * pos.xy;\npos.z -= bulge;\nreturn pos;\n}void main() {\nvec3 pos = bulge(aVertexPosition);\nvec3 pos_dx = bulge(aVertexPosition + vec3(0.01, 0.0, 0.0));\nvec3 pos_dy = bulge(aVertexPosition + vec3(0.0, 0.01, 0.0));\nvec3 dx = pos_dx - pos;\nvec3 dy = pos_dy - pos;\nvec3 normal = normalize(cross(dx, dy));vVertexPosition = normal;zPos = pos.z;gl_Position = vec4(pos, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":true,"uniforms":{},"isBackground":false,"heightSegments":500,"widthSegments":500},"id":"bulge_/_pinch"}],"options":{"name":"Like Midjourney (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.5","id":"m0aPI33Rvu592omcZh5o"}
