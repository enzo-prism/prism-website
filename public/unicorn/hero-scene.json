{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getBgColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.5000*2., 1e-5);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getBgColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sdf_shape","usesPingPong":false,"texture":false,"speed":0.66,"trackMouseMove":0,"trackAxes":"xy","mouseMomentum":1,"trackMouse":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nuniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.141592653;\nconst float PI2 = 6.283185306;\nconst int DISP_STEPS = 12;\nconst vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize;\nfloat customTexAspect;const mat3 ROT_Y_90 = mat3(\n0.0, 0.0, 1.0,\n0.0, 1.0, 0.0,\n-1.0, 0.0, 0.0\n);const mat3 ROT_Z_90 = mat3(\n0.0, -1.0, 0.0,\n1.0, 0.0, 0.0,\n0.0, 0.0, 1.0\n);const mat3 ROT_X_90 = mat3(\n1.0, 0.0, 0.0,\n0.0, 0.0, -1.0,\n0.0, 1.0, 0.0\n);mat3 rotY(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}mat3 rotX(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}mat3 rotZ(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}vec3 twistY(vec3 p, float amount) {\nfloat c = cos(amount * p.y);\nfloat s = sin(amount * p.y);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(m * p.xz, p.y);\n}vec3 twistX(vec3 p, float amount) {\nfloat c = cos(amount * p.x);\nfloat s = sin(amount * p.x);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(p.x, m * p.yz);\n}float sdOctahedron( vec3 p, float s ) {\nfloat shape = 0.5 + 0.5000;\np.x *= shape;\np.y *= (shape);\np.z *= (1.5-0.5000);\np = abs(p);\nfloat m = p.x+p.y+p.z-s;\nvec3 q;\nif( 3.0*p.x < m ) q = p.xyz;\nelse if( 3.0*p.y < m ) q = p.yzx;\nelse if( 3.0*p.z < m ) q = p.zxy;\nelse return m*0.57735027;\nfloat k = clamp(0.5*(q.z-q.y+s),0.0,s);\nreturn length(vec3(q.x,q.y-s+k,q.z-k));\n}float sdStar5(vec2 p, float r, float rf)\n{\nconst vec2 k1 = vec2(0.809016994375, -0.587785252292);\nconst vec2 k2 = vec2(-k1.x,k1.y);\np.x = abs(p.x);\np -= 2.0*max(dot(k1,p),0.0)*k1;\np -= 2.0*max(dot(k2,p),0.0)*k2;\np.x = abs(p.x);\np.y -= r;\nvec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\nfloat h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\nreturn length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}vec3 getRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getThreeDRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getAdjustedP(vec3 p) {\nfloat scale = max(0.3320, 0.000000001);\nfloat scaleFactor = 1.0/scale;\nvec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 0);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.0000 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000);\nvec2 axis = vec2(-1. * vec3(0.6585365853658537, 0.5613240418118467, 0.4995).y - 1. + mousePos.y/PI, vec3(0.6585365853658537, 0.5613240418118467, 0.4995).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02;\nfloat timeX = vec3(0, 1, 0).x * baseTime;\nfloat timeY = vec3(0, 1, 0).y * baseTime;\nfloat timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI);\nmat3 rotXMat = rotX(axis.x * PI);\nmat3 rotZMat = rotZ(vec3(0.6585365853658537, 0.5613240418118467, 0.4995).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat;\nmat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP;\nadjustedP = combinedAnimation * adjustedP;\nadjustedP = getThreeDRepeat(adjustedP);\nadjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y)));\nadjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP;\n}float getMergedSDF(vec3 p) {\np = getAdjustedP(p);\nreturn sdOctahedron(p, 1.5);\n}float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {\nfloat NdotV = abs(dot(eyeVector, worldNormal));\nfloat width = fwidth(dot(eyeVector, worldNormal));\nfloat threshold = 0.2;\nfloat edgeDampFactor = smoothstep(threshold, -threshold, width);\nfloat fresnelFactor = 1.0 - NdotV;\nreturn pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5);\n}vec3 noFrostOrDispersion(vec3 rd, vec3 normal) {\nfloat ior = 1.0 / (1.0 + 0.5000 * 0.25);\nvec3 refractedRay = refract(rd, normal, ior);\nreturn texture(uTexture, vTextureCoord - refractedRay.xy).rgb;\n}vec3 frostOrDispersion(vec3 rd, vec3 normal) {\nvec3 refractionColor = vec3(0);\nfloat iorBase = 1. + 0.5000 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.2500 * 1.2;for (int i = 0; i < DISP_STEPS; ++i) {\nfloat step = float(i) / float(DISP_STEPS);\nvec3 disp = step * dispCoefficients;\nvec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r);\nvec3 refractedRayG = refract(rd, normal, ior.g);\nvec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r;\nrefractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g;\nrefractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b;\n}return clamp(refractionColor / float(DISP_STEPS), 0.0, 1.0);\n}vec3 calculateNormal(vec3 p, float eps) {\nvec2 e = vec2(1.0, -1.0) * eps * 0.5;\nreturn normalize(\ne.xyy * getMergedSDF(p + e.xyy) +\ne.yyx * getMergedSDF(p + e.yyx) +\ne.yxy * getMergedSDF(p + e.yxy) +\ne.xxx * getMergedSDF(p + e.xxx)\n);\n}vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal);\nreturn noFrostOrDispersion(rd, normal);\n}float scene(vec3 p) {\nreturn max(0.0000000001, getMergedSDF(p) - (0.0000 + 0.005)) * max(0.3320, 0.000000001);\n}const int STEPS = 128;\nconst float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) {\nfloat pixelSize = 0.0025;\nfloat traveled = 0.;\nvec3 entryPoint = vec3(0.0);\nvec3 entryNormal = vec3(0.0);\nfloat partialAlpha = 0.0;\nfloat lastDistance = 0.0;\nfloat smoothing = mix(1., 4., 0.2000);for (int i = 0; i < STEPS; ++i) {\nvec3 currentPos = ro + rd * traveled;\nfloat distance = scene(currentPos);\nfloat progress = float(i)/float(STEPS);\nfloat step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) {\npartialAlpha = 1.;\nentryPoint = currentPos;\nentryNormal = calculateNormal(entryPoint, pixelSize * smoothing);\nbreak;\n}lastDistance = distance;traveled += max(step, pixelSize);\nif (traveled > MAX_DISTANCE) break;\n}if (partialAlpha == 0.0) {\nreturn texture(uTexture, vTextureCoord);\n}vec3 samplePosition = mix(rd, entryPoint, 0.0000);vec3 refractionColor = texture(uTexture, vTextureCoord).rgb;refractionColor = sampleTexture(samplePosition, entryNormal);\nvec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.4991289198606272, 0.410801393728223), vec3(0.25, 0.25, -3).z);\nvec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir);\nvec3 lightColor = mix(vec3(1), vec3(1, 0.44313725490196076, 0.32941176470588235), 1. - 0.7800);\nvec3 fresnelEffect = vec3(0.0);fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.5000 * vec3(1, 0.44313725490196076, 0.32941176470588235);vec3 specularEffect = vec3(0.0);vec3 halfwayDir = normalize(lightDir + rd);\nfloat specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.5000 + 0.01);\nspecularEffect = specFactor * 0.5000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect;\nvec3 finalColor = mix(refractionColor, vec3(1, 0.44313725490196076, 0.32941176470588235) * lightAndShadow, 0.7800);\nfinalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor;\n}out vec4 fragColor;void main() {\nvec4 col = vec4(0);\nvec4 bg = texture(uTexture, vTextureCoord);if(0.3320 <= 0.0001 || 1.0000 <= 0.0001) {\ncol = vec4(0);\nif(1 == 1) {\ncol = bg;\n}\nfragColor = col;\nreturn;\n}vec2 pos = vec2(0.4991289198606272, 0.410801393728223) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 uv = vTextureCoord - pos;\nfloat fovFactor = tan(radians(20.) * 0.5);\nvec3 rd = vec3(uv * fovFactor, 0.5);\ncol = rayMarch(viewDir, rd);\nfloat dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0;\ncol += dither;col = mix(bg, col, 1.0000);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"3d_shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"speed":0.67,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float TAU = 6.28318530718;vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\nreturn a + b*cos( TAU*(c*t+d) );\n}float drawExpandingRings(vec2 uv, vec2 center, float scale, float angle) {\nuv.x *= uResolution.x/uResolution.y;\ncenter.x *= uResolution.x/uResolution.y;\nvec2 skew = vec2(0.5000, 1. - 0.5000) * 2.;\nuv = uv * rot(0.0000 * TWO_PI) * skew;\ncenter = center * rot(0.0000 * TWO_PI) * skew;\nfloat modulo = fract(uTime * 0.02 + 0.5000);\nfloat ringRadius = scale * 0.5 * modulo;\nfloat distFromCenter = length(uv - center);\nfloat ringDist = abs(distFromCenter - ringRadius);\nfloat lineRadius = 1.0000 * modulo;\nfloat brightness = lineRadius / max(0.0001, 1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));brightness = brightness * max(0., 1.-modulo);return brightness * pow(1.-ringDist, 3.);\n}float getBeam(vec2 uv) {\nvec2 pos = vec2(0.49564459930313587, 0.410801393728223) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawExpandingRings(uv, pos, 0.8800, 0.0000);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);float beam = getBeam(uv);\nfloat ssBeam = smoothstep(0.0, 1.0, beam);\nfloat chroma = 0.4;vec3 beamColor = pal(beam,\n(vec3(1, 0.5372549019607843, 0.30196078431372547) + vec3(0.5)) * 0.5,\nvec3(0.5) - vec3(1, 0.5372549019607843, 0.30196078431372547),\nvec3(1.0 - chroma, 1.0, 1. + chroma),\nvec3(chroma, 0., -chroma)\n);beamColor = mix(beamColor, vec3(1, 0.5372549019607843, 0.30196078431372547), mix(1.0, ssBeam, 0.5800)) * beam;\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(5, Tonemap_tanh(beamColor), bg.rgb);\nvec3 result = mix(bg.rgb, blended, 1.0000);\nresult += dither;vec4 color = vec4(result, max(bg.a, beam));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"beam"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;const float PI2 = 6.28318530718;vec4 getBrightAreas(vec2 uv) {\nvec4 color = texture(uTexture, uv);\nfloat lum = dot(color.rgb, vec3(0.299, 0.587, 0.114));\ncolor = color * smoothstep(0.5000 - 0.1, 0.5000, lum);\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getBrightAreas(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(0 == 1) {\nfragColor = color;} else {\nfragColor = color;\n}\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI2 = 6.28318530718;float interleavedGradientNoise(vec2 st) {\nreturn fract(52.9829189 * fract(dot(st, vec2(0.06711056, 0.00583715))));\n}vec4 godRays(vec2 st) {\nvec3 color = vec3(0);\nfloat decay = mix(0.89, 0.965, 0.9400);\nvec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.0000);\nfloat weight = 1.0;\nfloat MAX_ITERATIONS = 32.0;\nvec2 stepDir = (pos - st) / MAX_ITERATIONS * (0.25 + min(1., 0.9400)) * 0.75;\nfloat noise = interleavedGradientNoise(st * uResolution);\nvec2 sampleUv = st + stepDir * noise;\nvec2 perpDir = vec2(-stepDir.y, stepDir.x);\nfloat intensity = 2.8 * 0.8000;for (float i = 0.0; i < MAX_ITERATIONS; i++) {\nfloat theta = i/MAX_ITERATIONS;\nsampleUv += stepDir + (perpDir * theta * sin((noise * 0.25) * (1.0 + theta) * 50.0)) * 0.0000 * 0.25;\ncolor += texture(uTexture, sampleUv).rgb * weight * intensity;\nweight *= decay;\nif(weight < 0.05) break;\n}\nreturn vec4(color / MAX_ITERATIONS, 1.0);\n}vec4 getGodRays(vec2 uv) {\nvec4 bg = texture(uBgTexture, uv);\nif(0.8000 <= 0.01) {\nreturn bg;\n}\nvec4 rays = godRays(uv);\nrays.rgb *= vec3(1, 0.7019607843137254, 0.2549019607843137);vec4 color;\ncolor.rgb = bg.rgb + rays.rgb;\ncolor.a = bg.a + rays.r;\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getGodRays(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(1 == 1) {\nfragColor = color;} else {\nfragColor = color;\n}\n}"] ,"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"includeBg":true}]},"id":"god_rays"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"glyphDither","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/media/glyphs/remix_knockout.png","sampler":"uSprite"},"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uSprite;\nuniform sampler2D uCustomTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.8620);float baseGrid = 1.0 / gridSize;\nvec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection;\nvec2 offsetUv = uv - pos;\nvec2 cell = floor(offsetUv / cellSize);\nvec2 cellCenter = (cell + 0.5) * cellSize;\nvec2 pixelatedCoord = cellCenter + pos;\nvec4 bg = texture(uTexture, vTextureCoord);\nvec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\nluminance = mix(luminance, 1.0 - luminance, float(0));\nfloat gamma = pow(mix(0.2, 2.2, 0.4400), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0);\nivec2 spriteTextureSize = textureSize(uSprite, 0);\nfloat selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(0 == 6));\nfloat GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(0 == 6));\nfloat scaleFactor = gridSize / GLYPH_HEIGHT;\nfloat numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT);\nfloat numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0);\nfloat spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0);\nfloat phaseOffset = floor(0.0000 * numSprites + 0.5);\nspriteIndexWithGamma = mod(spriteIndexWithGamma + phaseOffset, numSprites);\nfloat glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites;\nfloat normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2(spriteX, glyphIndex / numGlyphRows);vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection;\nvec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT;\nlocalOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2(localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY);vec4 spriteColor = vec4(0.0);spriteColor = texture(uSprite, spriteSheetUV);\nfloat alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4;\nvec3 col = cc;vec3 dithered = mix(\nmix(vec3(0.0), vec3(1.0), float(0)),\ncol,\nalpha\n);\ncolor.rgb = mix(bg.rgb, dithered, 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uSprite"}},"id":"glyph_dither"}],"options":{"name":"Fire Diamond (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.5","id":"O7KZ2PIb2QJHCyAxShuJ"}
